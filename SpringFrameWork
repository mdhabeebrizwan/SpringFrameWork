
inshallah we will start spring frame work
spring is the dependency injection frame work
Dependency:web(ui)-->bussiness layer--Data Layer
Bussiness layer is Dependent on Data Layer
suppose i want to show something to uservbdcnyut,m 
user layer is dependent on Bussiness Layer and bussiness layer is dependent on Data Layer

public class ComplexBusinessService
{
	SortAlgorith sortAlgorith;
}
To sort the given number ComplexBuss-> is Dependent on sortalgorithm,so sortalgorith is dependency of Complesbussiness

Before spring
public class ComplexBusinessService
{
	SortAlgorithm sortAlgorithm = new BubbleSortAlgorithm();

}
public class BubbleSortAlgorithm implements SortAlgorithm


in the above code ComplexBussiness is tight coupled with Bubblesort which is not good code 
ComplexBussiness is directly instantiate the BubbleSortAlgorithm suppose we want other sorting algorithm again i have instantiate quick which is not a good practice
How do we make this code loosely coupled.we remove tight coupling by removing by removing instantiation

SortAlgorithm soetAlgorithm = new BubbleSortAlgorithm();

ComlplexBusinessService businessService = new ComplexBusinessService(sortAlgorithm);

This code is good because this is loosely Coupled Programming.
what we doing hear we are instantiate object and populate the dependecies.
The same task will be done by springboot frame work user has specify the what are the identified objects and what are its dependencies,There are two comportant annotations that are present using which you can tell this to spring framework.that is what are the objects it needs to manage? and what are the dependencies of your particular class?
the annoatation is @componets
@componet
public class ComplexBusinessService
{
  @Autowired
	SortAlgorithm sortAlgorith;
}

@component 
public class BubbleSortAlgorithm implements SortAlgorithm

we are putting an @component on the of the complex bussiness service and the bubble sort,this is where we are telling spring ok you need to start managing instances of the comples business and bubble sort algorithm,and spring knows it needs to manage the instances of these two classes but how do you tell that this sort is dependent on Complex Class

The way you do that is by using another annotation @Autowired.as soon as you put @component it means that spring starts to manage instances of that class.and as soon as you put @Autowired that means spring would start looking for this dependency,it would start looking among the components it manages to find a matching thing for this sort alogrithm,so spring would internally do this.
The few terminology which are frequently associated wuth spring
Teminology 
1)Beans
2) Autowiring
3)Dependency Injection
4)Inversion of Control
5)IOC Container
6)Application Context

1)The First Terminolgy is Beans.
@componet
public class ComplexBusinessService
{
  @Autowired
	SortAlgorithm sortAlgorith;
}
@component 
public class BubbleSortAlgorithm implements SortAlgorithm

we are telling spring framework to create instances of the complex and bubble sort these are instances that spring manages.these are called beans.Beans are different objects that are managed by this spring framework.
2)Autowiring
The process where spring identifies the dependences,identifies the matches for the dependencies and populates them.
that process is called auto wiring.
so basically spring finds the right sort algorithm.it finds the bubble sort algorithn and crates an instance of that algorithm and pass them to ComplexBussiness Class
3)Dependency Injection 
spring framework understand the different annotations that you are putting on top of your classes,we are injecting this algorithm as dependency into the complex bussiness
4)Inversion of control

a)public class ComplexBusinessService
{
	SortAlgorithm sortAlgorithm = new BubbleSortAlgorithm();

}
public class BubbleSortAlgorithm implements SortAlgorithm

who is creating the instance of dependency in this example?
The class which needs it so the class which needs the dependency create an instance of the dependency
b)@componet
public class ComplexBusinessService
{
  @Autowired
	SortAlgorithm sortAlgorith;
}
@component 
public class BubbleSortAlgorithm implements SortAlgorithm

who is creating the instance of dependency in this example?
the spring framework is creating the instance in here. we are taking the control from the class that needs the dependency and giving the control to the framework to the spring framework and this is called inversion of control.

5)IOC Container
IOC Container is a generic terminology to represent anything that is implementing inversion of control.
In the case of spring framework the typical IOC container is the application context

6)Application context
is the one where all the beans are created and managed. application context is the most important part of the spring framework that is where all the core logic of spring frame work happens..
Autowired -- constructor,setter Method
@Component

we have three different options of resolving,multiple candidates avaiable for auto wiring.
so we got the application context by running the spring boot application class using the spring appliction

@primary
@name
@qualifier(Bubble)

@springBootApplication
it will automatically scans the package and the sub packages of the package where this is in.
Bean Scope
Default Singleton
when we are trying to get different instances of binary search what we are getting is the same bean
BinarySearchImpl binarySearch = applicationContext.getBean(BinarySearchImpl.class);
BinarySearchImpl binarySearch1= applicationContext.getBean(BinarySearchImpl.class);
@81f160
@81f160
This here we are refferring to the same object when you trying to get different instances of binary serch from the application context,what we geting  is the same bean.when we requesting the application context for the same bean twice we are getting the same instance of it back.
These kind of beans are called singleton beans.
in spring by default any bean is a singleton beans
a)Singleton - One instance per Spring Context
b)Prototype -New Bean whenever REQUESTED
c)request -One bean per HTTP request
d)session - One bean per HTTP USER Session(specific user)
By Default every bean scope is singleton we change by specify scope to Binary class
@scope("prototype")
after running we will get different scope.we asking Application context 2 Binary search using @prototype
Hardcoding prototype here is not really a good practice what we can do is use configurableBeanFactory.
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)

@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE,proxymode =ScopeProxyMode.TARGET_CLASS)
if we really want to have a different instance of the JDBCCONNECTION whenever we have a request for PersonDao than we need to configure something called a proxy

Difference between Spring Singleton and Gang of Four SingleTon

SpringContext SingleTon
when ever obn the same instance of PersonDao if iam calling getJdbcConnection again what would happend it would actually get new JdbcConnection(PROTOTYPE)
LOGGER.info(personDao.gerJdbcConnection());
LOGGER.info(personDao.gerJdbcConnection());

now i have two different JDBCConnecyion 
@3327729ad
@752da2d

Total 3 
SO THE SCOPE PROXY IS VERY IMPORTANT ESPECIALLY WHEN Even on the same instance(PERSONDAO)iam calling twice i will get two different for single instace call
Tht is the reason why a proxy becomes very important.wah wuld happen is ,instead of the JDBC CONNECTION AUTOWIRED into PersonDao,what would be autowired in,is something called a proxy so a proxu gets autowired in here,and whenever you call the getJdbcConnection the proxy would make sure taht it would retun the JDBC CONNECTION BACK


Difference Between GOF Design Pattern and Spring Singleton
in the Gof whenever they say singleTon it basically means one singleton per JVM,PER jvm you have one instanceof the beam howeever singleton in spring one instance per applicationcontect,in GOF Even if multiple application contexts are running in the same JVM,YOU Should just have one instance of that specific class,However when we talk about spring singleton there can be one instance of that class per one application context.
If their are five application contexts that are running in single JVM then if i hava spring beans of scope singleton then i will have five instances.However if you are having a singleton which meets the defination of Gang of Four design Pattern Singleton,there will only be one instances

